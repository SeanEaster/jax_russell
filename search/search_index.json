{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"jax_russell \u00b6 jax-rusell is a package that implements financial option formulas, and leverages Jax's autodifferentiation to support calculating \"the greeks.\" Formulas are generally taken from Espen Haug's The Complete Guide to Option Pricing Formulas . Documentation: https://SeanEaster.github.io/jax_russell GitHub: https://github.com/SeanEaster/jax_russell PyPI: https://pypi.org/project/jax_russell/ Free software: GPL-3.0-only Features \u00b6 Classes implementing standard tree methods, like Cox-Ross-Rubinstein and Rendleman Bartter Planned \u00b6 Black Scholes and variations More comprehensive testing Credits \u00b6 This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.","title":"Home"},{"location":"#jax_russell","text":"jax-rusell is a package that implements financial option formulas, and leverages Jax's autodifferentiation to support calculating \"the greeks.\" Formulas are generally taken from Espen Haug's The Complete Guide to Option Pricing Formulas . Documentation: https://SeanEaster.github.io/jax_russell GitHub: https://github.com/SeanEaster/jax_russell PyPI: https://pypi.org/project/jax_russell/ Free software: GPL-3.0-only","title":"jax_russell"},{"location":"#features","text":"Classes implementing standard tree methods, like Cox-Ross-Rubinstein and Rendleman Bartter","title":"Features"},{"location":"#planned","text":"Black Scholes and variations More comprehensive testing","title":"Planned"},{"location":"#credits","text":"This package was created with Cookiecutter and the waynerv/cookiecutter-pypackage project template.","title":"Credits"},{"location":"api/","text":"Top-level package for jax_russell. CRRBinomialTree \u00b6 Bases: BinomialTree Base class for binomial trees. jax_russell.BinomialTree houses operations common across various flavors of pricing models that employ binomial trees. For example, both European and American stock options TK Source code in jax_russell/trees.py 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 class CRRBinomialTree ( BinomialTree ): \"\"\"Base class for binomial trees. ``jax_russell.BinomialTree`` houses operations common across various flavors of pricing models that employ binomial trees. For example, both European and American stock options TK \"\"\" # noqa @typeguard . typechecked def value ( self , start_price : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" , ], volatility : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], time_to_expiration : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], risk_free_rate : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], cost_of_carry : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]: \"\"\"Calculate values for option contracts. Returns: jnp.array: contract values \"\"\" up_factors , down_factors = self . _calc_factors ( volatility , time_to_expiration , ) end_probabilities = self . _calc_end_probabilities ( up_factors , down_factors , time_to_expiration , cost_of_carry , ) if self . option_type == \"european\" : end_probabilities *= comb ( self . steps + 1 , jnp . arange ( self . steps + 1 )) end_underlying_values = self . _calc_end_values ( start_price , up_factors , down_factors , ) args = self . _transform_args_for_discounter ( time_to_expiration , risk_free_rate , cost_of_carry , is_call , strike , up_factors , down_factors , end_probabilities , end_underlying_values , ) return self . discounter ( * args ) def _calc_factors ( self , volatility : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], time_to_expiration : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> Tuple [ jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]]: \"\"\"Calculates the factor by which an asset price is multiplied for upward, downward movement at a step. Returns: jnp.array, jnp.array: factors on upward move, factors on downward move \"\"\" scaled_volatility = volatility * jnp . sqrt ( time_to_expiration / self . steps ) return jnp . exp ( scaled_volatility ), jnp . exp ( - scaled_volatility ) @typeguard . typechecked def _calc_end_probabilities ( self , up_factors : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], down_factors : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], time_to_expiration : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], cost_of_carry : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts n\" ]: # noqa \"\"\"Calculate the probability of arriving at every end node in the tree. Returns: jnp.Array: Array with probabiliities in the last dimension, size `self.steps + 1` \"\"\" p_up = self . _calc_transition_up_probabilities ( up_factors , down_factors , time_to_expiration , cost_of_carry , ) up_steps = jnp . arange ( self . steps + 1 ) end_probabilities = jnp . power ( jnp . expand_dims ( p_up , - 1 ), up_steps ) * jnp . power ( 1 - jnp . expand_dims ( p_up , - 1 ), self . steps - up_steps ) if self . option_type == \"european\" : end_probabilities *= comb ( self . steps , up_steps ) return end_probabilities __call__ ( * args , ** kwargs ) \u00b6 Value arrays of options. By default, __call__ checks its arguments against value() and passes them through. Returns: Type Description Float [ Array , '#contracts'] jnp.array: option values Source code in jax_russell/base.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def __call__ ( self , * args : Any , ** kwargs : Any , ) -> jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ]: \"\"\"Value arrays of options. By default, `__call__` checks its arguments against `value()` and passes them through. Returns: jnp.array: option values \"\"\" inspect . signature ( self . value ) . bind ( * args , ** kwargs ) return self . value ( * jnp . broadcast_arrays ( * args ), ** kwargs ) __init__ ( steps , option_type , discounter = None ) \u00b6 Parameters: Name Type Description Default steps int The number of time steps in the binomial tree. required Source code in jax_russell/trees.py 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 def __init__ ( self , steps : int , option_type : str , discounter : Union [ AmericanDiscounter , EuropeanDiscounter , None ] = None , ) -> None : \"\"\" Args: steps (int): The number of time steps in the binomial tree. \"\"\" # noqa assert option_type in [ \"european\" , \"american\" , ], f \"option_type must be one of `european` or `american` got { option_type } \" assert ( discounter is None or getattr ( discounter , \"steps\" , None ) is None or getattr ( discounter , \"steps\" , None ) == steps ) self . steps = steps self . option_type = option_type self . discounter = ( discounter if discounter is not None else AmericanDiscounter ( steps ) if option_type == 'american' else EuropeanDiscounter () ) first_order ( * args , ** kwargs ) \u00b6 Automatically calculate first-order greeks. Returns: Name Type Description _type_ description Source code in jax_russell/base.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @partial ( jax . jit , static_argnums = 0 ) def first_order ( self , * args , ** kwargs ): \"\"\"Automatically calculate first-order greeks. Returns: _type_: _description_ \"\"\" inspect . signature ( self ) . bind ( * args , ** kwargs ) return jnp . hstack ( jax . jacfwd ( self , self . argnums , )( * args , ** kwargs ) ) second_order ( * args , ** kwargs ) \u00b6 Automatically calculate second-order greeks. Returns: Name Type Description _type_ description Source code in jax_russell/base.py 93 94 95 96 97 98 99 100 101 102 103 104 @partial ( jax . jit , static_argnums = 0 ) def second_order ( self , * args , ** kwargs ): \"\"\"Automatically calculate second-order greeks. Returns: _type_: _description_ \"\"\" inspect . signature ( self ) . bind ( * args , ** kwargs ) return jax . jacfwd ( self . first_order , self . argnums , )( * args , ** kwargs ) value ( start_price , volatility , time_to_expiration , risk_free_rate , cost_of_carry , is_call , strike ) \u00b6 Calculate values for option contracts. Returns: Type Description Float [ Array , '*#contracts'] jnp.array: contract values Source code in jax_russell/trees.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 @typeguard . typechecked def value ( self , start_price : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" , ], volatility : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], time_to_expiration : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], risk_free_rate : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], cost_of_carry : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]: \"\"\"Calculate values for option contracts. Returns: jnp.array: contract values \"\"\" up_factors , down_factors = self . _calc_factors ( volatility , time_to_expiration , ) end_probabilities = self . _calc_end_probabilities ( up_factors , down_factors , time_to_expiration , cost_of_carry , ) if self . option_type == \"european\" : end_probabilities *= comb ( self . steps + 1 , jnp . arange ( self . steps + 1 )) end_underlying_values = self . _calc_end_values ( start_price , up_factors , down_factors , ) args = self . _transform_args_for_discounter ( time_to_expiration , risk_free_rate , cost_of_carry , is_call , strike , up_factors , down_factors , end_probabilities , end_underlying_values , ) return self . discounter ( * args ) ExerciseValuer \u00b6 Bases: ABC Abstract class for Callables that implement, or approximate, the max(exercise value, 0) operation. This is applied in the intermediate steps of a binomial tree. Source code in jax_russell/trees.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class ExerciseValuer ( abc . ABC ): \"\"\"Abstract class for Callables that implement, or approximate, the max(exercise value, 0) operation. This is applied in the intermediate steps of a binomial tree. \"\"\" @typeguard . typechecked def __call__ ( self , underlying_values : jaxtyping . Float [ jaxtyping . Array , \"*#contracts n\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]: \"\"\"Calculate or approximate the value of exercising an option. Args: underlying_values (jaxtyping.Float[jaxtyping.Array, \"#contracts n\"]): value of the underlying asset strike (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): option strike prices is_call (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): whether each option is a call (1.0) or put (0.0) Returns: jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]: Exercise values. \"\"\" return self . adjust ( self . _calc_unadjusted_value ( underlying_values , strike , is_call , ) ) @typeguard . typechecked def _calc_unadjusted_value ( self , underlying_values : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]: return ( underlying_values - strike ) * ( 2 * is_call - 1 ) @abc . abstractmethod def adjust ( self , unadjusted_values : jaxtyping . Float [ jax . Array , \"*\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*\" ]: \"\"\"Adjust value difference to calculate an intermediate exercise value. This method should transform the difference between strike and underlying, i.e. `underlying - strike` for calls, `strike - underlying` for puts, to an exercise value. For example, a standard binomial tree uses max(unadjusted_values, 0.0). \"\"\" # noqa __call__ ( underlying_values , strike , is_call ) \u00b6 Calculate or approximate the value of exercising an option. Parameters: Name Type Description Default underlying_values Float [ Array , '#contracts n'] value of the underlying asset required strike Float [ Array , '*#contracts'] option strike prices required is_call Float [ Array , '*#contracts'] whether each option is a call (1.0) or put (0.0) required Returns: Type Description Float [ Array , '*#contracts'] jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]: Exercise values. Source code in jax_russell/trees.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @typeguard . typechecked def __call__ ( self , underlying_values : jaxtyping . Float [ jaxtyping . Array , \"*#contracts n\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]: \"\"\"Calculate or approximate the value of exercising an option. Args: underlying_values (jaxtyping.Float[jaxtyping.Array, \"#contracts n\"]): value of the underlying asset strike (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): option strike prices is_call (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): whether each option is a call (1.0) or put (0.0) Returns: jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]: Exercise values. \"\"\" return self . adjust ( self . _calc_unadjusted_value ( underlying_values , strike , is_call , ) ) adjust ( unadjusted_values ) abstractmethod \u00b6 Adjust value difference to calculate an intermediate exercise value. This method should transform the difference between strike and underlying, i.e. underlying - strike for calls, strike - underlying for puts, to an exercise value. For example, a standard binomial tree uses max(unadjusted_values, 0.0). Source code in jax_russell/trees.py 95 96 97 98 99 100 101 102 103 104 @abc . abstractmethod def adjust ( self , unadjusted_values : jaxtyping . Float [ jax . Array , \"*\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*\" ]: \"\"\"Adjust value difference to calculate an intermediate exercise value. This method should transform the difference between strike and underlying, i.e. `underlying - strike` for calls, `strike - underlying` for puts, to an exercise value. For example, a standard binomial tree uses max(unadjusted_values, 0.0). \"\"\" # noqa MaxValuer \u00b6 Bases: ExerciseValuer Implements the standard maximum operation found in intermediate steps in binomial trees. Source code in jax_russell/trees.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 class MaxValuer ( ExerciseValuer ): \"\"\"Implements the standard maximum operation found in intermediate steps in binomial trees.\"\"\" def adjust ( self , unadjusted_values : jaxtyping . Float [ jax . Array , \"*\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*\" ]: \"\"\"Adjust signed strike-underlying differences by applying the max op. Args: unadjusted_values (jaxtyping.Float[jax.Array, \"*\"]): `underlying - strike` for calls, `strike - underlying` for puts Returns: jaxtyping.Float[jaxtyping.Array, \"*\"]: element-wise max(unadjusted_values, 0.0) \"\"\" # noqa return jnp . maximum ( unadjusted_values , 0.0 ) __call__ ( underlying_values , strike , is_call ) \u00b6 Calculate or approximate the value of exercising an option. Parameters: Name Type Description Default underlying_values Float [ Array , '#contracts n'] value of the underlying asset required strike Float [ Array , '*#contracts'] option strike prices required is_call Float [ Array , '*#contracts'] whether each option is a call (1.0) or put (0.0) required Returns: Type Description Float [ Array , '*#contracts'] jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]: Exercise values. Source code in jax_russell/trees.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @typeguard . typechecked def __call__ ( self , underlying_values : jaxtyping . Float [ jaxtyping . Array , \"*#contracts n\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]: \"\"\"Calculate or approximate the value of exercising an option. Args: underlying_values (jaxtyping.Float[jaxtyping.Array, \"#contracts n\"]): value of the underlying asset strike (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): option strike prices is_call (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): whether each option is a call (1.0) or put (0.0) Returns: jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]: Exercise values. \"\"\" return self . adjust ( self . _calc_unadjusted_value ( underlying_values , strike , is_call , ) ) adjust ( unadjusted_values ) \u00b6 Adjust signed strike-underlying differences by applying the max op. Parameters: Name Type Description Default unadjusted_values Float [ Array , '*'] underlying - strike for calls, strike - underlying for puts required Returns: Type Description Float [ Array , '*'] jaxtyping.Float[jaxtyping.Array, \"*\"]: element-wise max(unadjusted_values, 0.0) Source code in jax_russell/trees.py 110 111 112 113 114 115 116 117 118 119 120 121 122 def adjust ( self , unadjusted_values : jaxtyping . Float [ jax . Array , \"*\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*\" ]: \"\"\"Adjust signed strike-underlying differences by applying the max op. Args: unadjusted_values (jaxtyping.Float[jax.Array, \"*\"]): `underlying - strike` for calls, `strike - underlying` for puts Returns: jaxtyping.Float[jaxtyping.Array, \"*\"]: element-wise max(unadjusted_values, 0.0) \"\"\" # noqa return jnp . maximum ( unadjusted_values , 0.0 ) SoftplusValuer \u00b6 Bases: ExerciseValuer Approximate the maximum operation using a softplus function. This Callable will return log(1 + exp(kx)) / k where k is the sharpness parameter. Source code in jax_russell/trees.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 class SoftplusValuer ( ExerciseValuer ): \"\"\"Approximate the maximum operation using a softplus function. This Callable will return `log(1 + exp(kx)) / k` where k is the sharpness parameter. \"\"\" def __init__ ( self , sharpness : float = 1.0 ) -> None : \"\"\" Args: sharpness (float): sharpness parameter k \"\"\" # noqa super () . __init__ () self . sharpness = sharpness def adjust ( self , unadjusted_values : jaxtyping . Float [ jax . Array , \"*\" ], sharpness : Union [ None , float ] = None , ) -> jaxtyping . Float [ jaxtyping . Array , \"*\" ]: \"\"\"Adjust using the softplus function. Args: unadjusted_values: jaxtyping.Float[jax.Array, \"*\"]): `underlying - strike` for calls, `strike - underlying` for puts sharpness: If None, uses `self.sharpness` Returns: jaxtyping.Float[jaxtyping.Array, \"*\"]: element-wise softplus \"\"\" # noqa return jnp . logaddexp (( self . sharpness if sharpness is None else sharpness ) * unadjusted_values , 0.0 ) / ( self . sharpness if sharpness is None else sharpness ) __call__ ( underlying_values , strike , is_call ) \u00b6 Calculate or approximate the value of exercising an option. Parameters: Name Type Description Default underlying_values Float [ Array , '#contracts n'] value of the underlying asset required strike Float [ Array , '*#contracts'] option strike prices required is_call Float [ Array , '*#contracts'] whether each option is a call (1.0) or put (0.0) required Returns: Type Description Float [ Array , '*#contracts'] jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]: Exercise values. Source code in jax_russell/trees.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @typeguard . typechecked def __call__ ( self , underlying_values : jaxtyping . Float [ jaxtyping . Array , \"*#contracts n\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]: \"\"\"Calculate or approximate the value of exercising an option. Args: underlying_values (jaxtyping.Float[jaxtyping.Array, \"#contracts n\"]): value of the underlying asset strike (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): option strike prices is_call (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): whether each option is a call (1.0) or put (0.0) Returns: jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]: Exercise values. \"\"\" return self . adjust ( self . _calc_unadjusted_value ( underlying_values , strike , is_call , ) ) __init__ ( sharpness = 1.0 ) \u00b6 Parameters: Name Type Description Default sharpness float sharpness parameter k 1.0 Source code in jax_russell/trees.py 131 132 133 134 135 136 137 138 def __init__ ( self , sharpness : float = 1.0 ) -> None : \"\"\" Args: sharpness (float): sharpness parameter k \"\"\" # noqa super () . __init__ () self . sharpness = sharpness adjust ( unadjusted_values , sharpness = None ) \u00b6 Adjust using the softplus function. Parameters: Name Type Description Default unadjusted_values Float [ Array , '*'] jaxtyping.Float[jax.Array, \"*\"]): underlying - strike for calls, strike - underlying for puts required sharpness Union [None, float ] If None, uses self.sharpness None Returns: Type Description Float [ Array , '*'] jaxtyping.Float[jaxtyping.Array, \"*\"]: element-wise softplus Source code in jax_russell/trees.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def adjust ( self , unadjusted_values : jaxtyping . Float [ jax . Array , \"*\" ], sharpness : Union [ None , float ] = None , ) -> jaxtyping . Float [ jaxtyping . Array , \"*\" ]: \"\"\"Adjust using the softplus function. Args: unadjusted_values: jaxtyping.Float[jax.Array, \"*\"]): `underlying - strike` for calls, `strike - underlying` for puts sharpness: If None, uses `self.sharpness` Returns: jaxtyping.Float[jaxtyping.Array, \"*\"]: element-wise softplus \"\"\" # noqa return jnp . logaddexp (( self . sharpness if sharpness is None else sharpness ) * unadjusted_values , 0.0 ) / ( self . sharpness if sharpness is None else sharpness ) ValuationModel \u00b6 Bases: ABC Abstract class for valuation methods. Source code in jax_russell/base.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class ValuationModel ( abc . ABC ): \"\"\"Abstract class for valuation methods.\"\"\" argnums = list ( range ( 4 )) @abc . abstractmethod def value ( self , start_price : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" , ], volatility : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], time_to_expiration : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], risk_free_rate : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], cost_of_carry : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ]: \"\"\"Calculate the value of an option. This method is used internally by `__call__()`, and should return the value of options. By default, `__call__()` is a pass through to `value()`, but many available mixins overwrite this behavior to pass arguments to `value()`. In these cases, this allows the single, general method `value()` to implement valuations, while leveraging `__call__()` for security-specific argument logic and meaningful autodifferentiation. \"\"\" # noqa def __call__ ( self , * args : Any , ** kwargs : Any , ) -> jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ]: \"\"\"Value arrays of options. By default, `__call__` checks its arguments against `value()` and passes them through. Returns: jnp.array: option values \"\"\" inspect . signature ( self . value ) . bind ( * args , ** kwargs ) return self . value ( * jnp . broadcast_arrays ( * args ), ** kwargs ) @partial ( jax . jit , static_argnums = 0 ) def first_order ( self , * args , ** kwargs ): \"\"\"Automatically calculate first-order greeks. Returns: _type_: _description_ \"\"\" inspect . signature ( self ) . bind ( * args , ** kwargs ) return jnp . hstack ( jax . jacfwd ( self , self . argnums , )( * args , ** kwargs ) ) @partial ( jax . jit , static_argnums = 0 ) def second_order ( self , * args , ** kwargs ): \"\"\"Automatically calculate second-order greeks. Returns: _type_: _description_ \"\"\" inspect . signature ( self ) . bind ( * args , ** kwargs ) return jax . jacfwd ( self . first_order , self . argnums , )( * args , ** kwargs ) __call__ ( * args , ** kwargs ) \u00b6 Value arrays of options. By default, __call__ checks its arguments against value() and passes them through. Returns: Type Description Float [ Array , '#contracts'] jnp.array: option values Source code in jax_russell/base.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def __call__ ( self , * args : Any , ** kwargs : Any , ) -> jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ]: \"\"\"Value arrays of options. By default, `__call__` checks its arguments against `value()` and passes them through. Returns: jnp.array: option values \"\"\" inspect . signature ( self . value ) . bind ( * args , ** kwargs ) return self . value ( * jnp . broadcast_arrays ( * args ), ** kwargs ) first_order ( * args , ** kwargs ) \u00b6 Automatically calculate first-order greeks. Returns: Name Type Description _type_ description Source code in jax_russell/base.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @partial ( jax . jit , static_argnums = 0 ) def first_order ( self , * args , ** kwargs ): \"\"\"Automatically calculate first-order greeks. Returns: _type_: _description_ \"\"\" inspect . signature ( self ) . bind ( * args , ** kwargs ) return jnp . hstack ( jax . jacfwd ( self , self . argnums , )( * args , ** kwargs ) ) second_order ( * args , ** kwargs ) \u00b6 Automatically calculate second-order greeks. Returns: Name Type Description _type_ description Source code in jax_russell/base.py 93 94 95 96 97 98 99 100 101 102 103 104 @partial ( jax . jit , static_argnums = 0 ) def second_order ( self , * args , ** kwargs ): \"\"\"Automatically calculate second-order greeks. Returns: _type_: _description_ \"\"\" inspect . signature ( self ) . bind ( * args , ** kwargs ) return jax . jacfwd ( self . first_order , self . argnums , )( * args , ** kwargs ) value ( start_price , volatility , time_to_expiration , risk_free_rate , cost_of_carry , is_call , strike ) abstractmethod \u00b6 Calculate the value of an option. This method is used internally by __call__() , and should return the value of options. By default, __call__() is a pass through to value() , but many available mixins overwrite this behavior to pass arguments to value() . In these cases, this allows the single, general method value() to implement valuations, while leveraging __call__() for security-specific argument logic and meaningful autodifferentiation. Source code in jax_russell/base.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @abc . abstractmethod def value ( self , start_price : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" , ], volatility : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], time_to_expiration : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], risk_free_rate : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], cost_of_carry : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ]: \"\"\"Calculate the value of an option. This method is used internally by `__call__()`, and should return the value of options. By default, `__call__()` is a pass through to `value()`, but many available mixins overwrite this behavior to pass arguments to `value()`. In these cases, this allows the single, general method `value()` to implement valuations, while leveraging `__call__()` for security-specific argument logic and meaningful autodifferentiation. \"\"\" # noqa","title":"Modules"},{"location":"api/#jax_russell.CRRBinomialTree","text":"Bases: BinomialTree Base class for binomial trees. jax_russell.BinomialTree houses operations common across various flavors of pricing models that employ binomial trees. For example, both European and American stock options TK Source code in jax_russell/trees.py 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 class CRRBinomialTree ( BinomialTree ): \"\"\"Base class for binomial trees. ``jax_russell.BinomialTree`` houses operations common across various flavors of pricing models that employ binomial trees. For example, both European and American stock options TK \"\"\" # noqa @typeguard . typechecked def value ( self , start_price : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" , ], volatility : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], time_to_expiration : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], risk_free_rate : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], cost_of_carry : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]: \"\"\"Calculate values for option contracts. Returns: jnp.array: contract values \"\"\" up_factors , down_factors = self . _calc_factors ( volatility , time_to_expiration , ) end_probabilities = self . _calc_end_probabilities ( up_factors , down_factors , time_to_expiration , cost_of_carry , ) if self . option_type == \"european\" : end_probabilities *= comb ( self . steps + 1 , jnp . arange ( self . steps + 1 )) end_underlying_values = self . _calc_end_values ( start_price , up_factors , down_factors , ) args = self . _transform_args_for_discounter ( time_to_expiration , risk_free_rate , cost_of_carry , is_call , strike , up_factors , down_factors , end_probabilities , end_underlying_values , ) return self . discounter ( * args ) def _calc_factors ( self , volatility : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], time_to_expiration : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> Tuple [ jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]]: \"\"\"Calculates the factor by which an asset price is multiplied for upward, downward movement at a step. Returns: jnp.array, jnp.array: factors on upward move, factors on downward move \"\"\" scaled_volatility = volatility * jnp . sqrt ( time_to_expiration / self . steps ) return jnp . exp ( scaled_volatility ), jnp . exp ( - scaled_volatility ) @typeguard . typechecked def _calc_end_probabilities ( self , up_factors : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], down_factors : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], time_to_expiration : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], cost_of_carry : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts n\" ]: # noqa \"\"\"Calculate the probability of arriving at every end node in the tree. Returns: jnp.Array: Array with probabiliities in the last dimension, size `self.steps + 1` \"\"\" p_up = self . _calc_transition_up_probabilities ( up_factors , down_factors , time_to_expiration , cost_of_carry , ) up_steps = jnp . arange ( self . steps + 1 ) end_probabilities = jnp . power ( jnp . expand_dims ( p_up , - 1 ), up_steps ) * jnp . power ( 1 - jnp . expand_dims ( p_up , - 1 ), self . steps - up_steps ) if self . option_type == \"european\" : end_probabilities *= comb ( self . steps , up_steps ) return end_probabilities","title":"CRRBinomialTree"},{"location":"api/#jax_russell.CRRBinomialTree.__call__","text":"Value arrays of options. By default, __call__ checks its arguments against value() and passes them through. Returns: Type Description Float [ Array , '#contracts'] jnp.array: option values Source code in jax_russell/base.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def __call__ ( self , * args : Any , ** kwargs : Any , ) -> jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ]: \"\"\"Value arrays of options. By default, `__call__` checks its arguments against `value()` and passes them through. Returns: jnp.array: option values \"\"\" inspect . signature ( self . value ) . bind ( * args , ** kwargs ) return self . value ( * jnp . broadcast_arrays ( * args ), ** kwargs )","title":"__call__()"},{"location":"api/#jax_russell.CRRBinomialTree.__init__","text":"Parameters: Name Type Description Default steps int The number of time steps in the binomial tree. required Source code in jax_russell/trees.py 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 def __init__ ( self , steps : int , option_type : str , discounter : Union [ AmericanDiscounter , EuropeanDiscounter , None ] = None , ) -> None : \"\"\" Args: steps (int): The number of time steps in the binomial tree. \"\"\" # noqa assert option_type in [ \"european\" , \"american\" , ], f \"option_type must be one of `european` or `american` got { option_type } \" assert ( discounter is None or getattr ( discounter , \"steps\" , None ) is None or getattr ( discounter , \"steps\" , None ) == steps ) self . steps = steps self . option_type = option_type self . discounter = ( discounter if discounter is not None else AmericanDiscounter ( steps ) if option_type == 'american' else EuropeanDiscounter () )","title":"__init__()"},{"location":"api/#jax_russell.CRRBinomialTree.first_order","text":"Automatically calculate first-order greeks. Returns: Name Type Description _type_ description Source code in jax_russell/base.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @partial ( jax . jit , static_argnums = 0 ) def first_order ( self , * args , ** kwargs ): \"\"\"Automatically calculate first-order greeks. Returns: _type_: _description_ \"\"\" inspect . signature ( self ) . bind ( * args , ** kwargs ) return jnp . hstack ( jax . jacfwd ( self , self . argnums , )( * args , ** kwargs ) )","title":"first_order()"},{"location":"api/#jax_russell.CRRBinomialTree.second_order","text":"Automatically calculate second-order greeks. Returns: Name Type Description _type_ description Source code in jax_russell/base.py 93 94 95 96 97 98 99 100 101 102 103 104 @partial ( jax . jit , static_argnums = 0 ) def second_order ( self , * args , ** kwargs ): \"\"\"Automatically calculate second-order greeks. Returns: _type_: _description_ \"\"\" inspect . signature ( self ) . bind ( * args , ** kwargs ) return jax . jacfwd ( self . first_order , self . argnums , )( * args , ** kwargs )","title":"second_order()"},{"location":"api/#jax_russell.CRRBinomialTree.value","text":"Calculate values for option contracts. Returns: Type Description Float [ Array , '*#contracts'] jnp.array: contract values Source code in jax_russell/trees.py 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 @typeguard . typechecked def value ( self , start_price : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" , ], volatility : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], time_to_expiration : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], risk_free_rate : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], cost_of_carry : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]: \"\"\"Calculate values for option contracts. Returns: jnp.array: contract values \"\"\" up_factors , down_factors = self . _calc_factors ( volatility , time_to_expiration , ) end_probabilities = self . _calc_end_probabilities ( up_factors , down_factors , time_to_expiration , cost_of_carry , ) if self . option_type == \"european\" : end_probabilities *= comb ( self . steps + 1 , jnp . arange ( self . steps + 1 )) end_underlying_values = self . _calc_end_values ( start_price , up_factors , down_factors , ) args = self . _transform_args_for_discounter ( time_to_expiration , risk_free_rate , cost_of_carry , is_call , strike , up_factors , down_factors , end_probabilities , end_underlying_values , ) return self . discounter ( * args )","title":"value()"},{"location":"api/#jax_russell.ExerciseValuer","text":"Bases: ABC Abstract class for Callables that implement, or approximate, the max(exercise value, 0) operation. This is applied in the intermediate steps of a binomial tree. Source code in jax_russell/trees.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class ExerciseValuer ( abc . ABC ): \"\"\"Abstract class for Callables that implement, or approximate, the max(exercise value, 0) operation. This is applied in the intermediate steps of a binomial tree. \"\"\" @typeguard . typechecked def __call__ ( self , underlying_values : jaxtyping . Float [ jaxtyping . Array , \"*#contracts n\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]: \"\"\"Calculate or approximate the value of exercising an option. Args: underlying_values (jaxtyping.Float[jaxtyping.Array, \"#contracts n\"]): value of the underlying asset strike (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): option strike prices is_call (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): whether each option is a call (1.0) or put (0.0) Returns: jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]: Exercise values. \"\"\" return self . adjust ( self . _calc_unadjusted_value ( underlying_values , strike , is_call , ) ) @typeguard . typechecked def _calc_unadjusted_value ( self , underlying_values : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]: return ( underlying_values - strike ) * ( 2 * is_call - 1 ) @abc . abstractmethod def adjust ( self , unadjusted_values : jaxtyping . Float [ jax . Array , \"*\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*\" ]: \"\"\"Adjust value difference to calculate an intermediate exercise value. This method should transform the difference between strike and underlying, i.e. `underlying - strike` for calls, `strike - underlying` for puts, to an exercise value. For example, a standard binomial tree uses max(unadjusted_values, 0.0). \"\"\" # noqa","title":"ExerciseValuer"},{"location":"api/#jax_russell.ExerciseValuer.__call__","text":"Calculate or approximate the value of exercising an option. Parameters: Name Type Description Default underlying_values Float [ Array , '#contracts n'] value of the underlying asset required strike Float [ Array , '*#contracts'] option strike prices required is_call Float [ Array , '*#contracts'] whether each option is a call (1.0) or put (0.0) required Returns: Type Description Float [ Array , '*#contracts'] jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]: Exercise values. Source code in jax_russell/trees.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @typeguard . typechecked def __call__ ( self , underlying_values : jaxtyping . Float [ jaxtyping . Array , \"*#contracts n\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]: \"\"\"Calculate or approximate the value of exercising an option. Args: underlying_values (jaxtyping.Float[jaxtyping.Array, \"#contracts n\"]): value of the underlying asset strike (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): option strike prices is_call (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): whether each option is a call (1.0) or put (0.0) Returns: jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]: Exercise values. \"\"\" return self . adjust ( self . _calc_unadjusted_value ( underlying_values , strike , is_call , ) )","title":"__call__()"},{"location":"api/#jax_russell.ExerciseValuer.adjust","text":"Adjust value difference to calculate an intermediate exercise value. This method should transform the difference between strike and underlying, i.e. underlying - strike for calls, strike - underlying for puts, to an exercise value. For example, a standard binomial tree uses max(unadjusted_values, 0.0). Source code in jax_russell/trees.py 95 96 97 98 99 100 101 102 103 104 @abc . abstractmethod def adjust ( self , unadjusted_values : jaxtyping . Float [ jax . Array , \"*\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*\" ]: \"\"\"Adjust value difference to calculate an intermediate exercise value. This method should transform the difference between strike and underlying, i.e. `underlying - strike` for calls, `strike - underlying` for puts, to an exercise value. For example, a standard binomial tree uses max(unadjusted_values, 0.0). \"\"\" # noqa","title":"adjust()"},{"location":"api/#jax_russell.MaxValuer","text":"Bases: ExerciseValuer Implements the standard maximum operation found in intermediate steps in binomial trees. Source code in jax_russell/trees.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 class MaxValuer ( ExerciseValuer ): \"\"\"Implements the standard maximum operation found in intermediate steps in binomial trees.\"\"\" def adjust ( self , unadjusted_values : jaxtyping . Float [ jax . Array , \"*\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*\" ]: \"\"\"Adjust signed strike-underlying differences by applying the max op. Args: unadjusted_values (jaxtyping.Float[jax.Array, \"*\"]): `underlying - strike` for calls, `strike - underlying` for puts Returns: jaxtyping.Float[jaxtyping.Array, \"*\"]: element-wise max(unadjusted_values, 0.0) \"\"\" # noqa return jnp . maximum ( unadjusted_values , 0.0 )","title":"MaxValuer"},{"location":"api/#jax_russell.MaxValuer.__call__","text":"Calculate or approximate the value of exercising an option. Parameters: Name Type Description Default underlying_values Float [ Array , '#contracts n'] value of the underlying asset required strike Float [ Array , '*#contracts'] option strike prices required is_call Float [ Array , '*#contracts'] whether each option is a call (1.0) or put (0.0) required Returns: Type Description Float [ Array , '*#contracts'] jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]: Exercise values. Source code in jax_russell/trees.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @typeguard . typechecked def __call__ ( self , underlying_values : jaxtyping . Float [ jaxtyping . Array , \"*#contracts n\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]: \"\"\"Calculate or approximate the value of exercising an option. Args: underlying_values (jaxtyping.Float[jaxtyping.Array, \"#contracts n\"]): value of the underlying asset strike (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): option strike prices is_call (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): whether each option is a call (1.0) or put (0.0) Returns: jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]: Exercise values. \"\"\" return self . adjust ( self . _calc_unadjusted_value ( underlying_values , strike , is_call , ) )","title":"__call__()"},{"location":"api/#jax_russell.MaxValuer.adjust","text":"Adjust signed strike-underlying differences by applying the max op. Parameters: Name Type Description Default unadjusted_values Float [ Array , '*'] underlying - strike for calls, strike - underlying for puts required Returns: Type Description Float [ Array , '*'] jaxtyping.Float[jaxtyping.Array, \"*\"]: element-wise max(unadjusted_values, 0.0) Source code in jax_russell/trees.py 110 111 112 113 114 115 116 117 118 119 120 121 122 def adjust ( self , unadjusted_values : jaxtyping . Float [ jax . Array , \"*\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*\" ]: \"\"\"Adjust signed strike-underlying differences by applying the max op. Args: unadjusted_values (jaxtyping.Float[jax.Array, \"*\"]): `underlying - strike` for calls, `strike - underlying` for puts Returns: jaxtyping.Float[jaxtyping.Array, \"*\"]: element-wise max(unadjusted_values, 0.0) \"\"\" # noqa return jnp . maximum ( unadjusted_values , 0.0 )","title":"adjust()"},{"location":"api/#jax_russell.SoftplusValuer","text":"Bases: ExerciseValuer Approximate the maximum operation using a softplus function. This Callable will return log(1 + exp(kx)) / k where k is the sharpness parameter. Source code in jax_russell/trees.py 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 class SoftplusValuer ( ExerciseValuer ): \"\"\"Approximate the maximum operation using a softplus function. This Callable will return `log(1 + exp(kx)) / k` where k is the sharpness parameter. \"\"\" def __init__ ( self , sharpness : float = 1.0 ) -> None : \"\"\" Args: sharpness (float): sharpness parameter k \"\"\" # noqa super () . __init__ () self . sharpness = sharpness def adjust ( self , unadjusted_values : jaxtyping . Float [ jax . Array , \"*\" ], sharpness : Union [ None , float ] = None , ) -> jaxtyping . Float [ jaxtyping . Array , \"*\" ]: \"\"\"Adjust using the softplus function. Args: unadjusted_values: jaxtyping.Float[jax.Array, \"*\"]): `underlying - strike` for calls, `strike - underlying` for puts sharpness: If None, uses `self.sharpness` Returns: jaxtyping.Float[jaxtyping.Array, \"*\"]: element-wise softplus \"\"\" # noqa return jnp . logaddexp (( self . sharpness if sharpness is None else sharpness ) * unadjusted_values , 0.0 ) / ( self . sharpness if sharpness is None else sharpness )","title":"SoftplusValuer"},{"location":"api/#jax_russell.SoftplusValuer.__call__","text":"Calculate or approximate the value of exercising an option. Parameters: Name Type Description Default underlying_values Float [ Array , '#contracts n'] value of the underlying asset required strike Float [ Array , '*#contracts'] option strike prices required is_call Float [ Array , '*#contracts'] whether each option is a call (1.0) or put (0.0) required Returns: Type Description Float [ Array , '*#contracts'] jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]: Exercise values. Source code in jax_russell/trees.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @typeguard . typechecked def __call__ ( self , underlying_values : jaxtyping . Float [ jaxtyping . Array , \"*#contracts n\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"*#contracts\" ]: \"\"\"Calculate or approximate the value of exercising an option. Args: underlying_values (jaxtyping.Float[jaxtyping.Array, \"#contracts n\"]): value of the underlying asset strike (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): option strike prices is_call (jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]): whether each option is a call (1.0) or put (0.0) Returns: jaxtyping.Float[jaxtyping.Array, \"*#contracts\"]: Exercise values. \"\"\" return self . adjust ( self . _calc_unadjusted_value ( underlying_values , strike , is_call , ) )","title":"__call__()"},{"location":"api/#jax_russell.SoftplusValuer.__init__","text":"Parameters: Name Type Description Default sharpness float sharpness parameter k 1.0 Source code in jax_russell/trees.py 131 132 133 134 135 136 137 138 def __init__ ( self , sharpness : float = 1.0 ) -> None : \"\"\" Args: sharpness (float): sharpness parameter k \"\"\" # noqa super () . __init__ () self . sharpness = sharpness","title":"__init__()"},{"location":"api/#jax_russell.SoftplusValuer.adjust","text":"Adjust using the softplus function. Parameters: Name Type Description Default unadjusted_values Float [ Array , '*'] jaxtyping.Float[jax.Array, \"*\"]): underlying - strike for calls, strike - underlying for puts required sharpness Union [None, float ] If None, uses self.sharpness None Returns: Type Description Float [ Array , '*'] jaxtyping.Float[jaxtyping.Array, \"*\"]: element-wise softplus Source code in jax_russell/trees.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def adjust ( self , unadjusted_values : jaxtyping . Float [ jax . Array , \"*\" ], sharpness : Union [ None , float ] = None , ) -> jaxtyping . Float [ jaxtyping . Array , \"*\" ]: \"\"\"Adjust using the softplus function. Args: unadjusted_values: jaxtyping.Float[jax.Array, \"*\"]): `underlying - strike` for calls, `strike - underlying` for puts sharpness: If None, uses `self.sharpness` Returns: jaxtyping.Float[jaxtyping.Array, \"*\"]: element-wise softplus \"\"\" # noqa return jnp . logaddexp (( self . sharpness if sharpness is None else sharpness ) * unadjusted_values , 0.0 ) / ( self . sharpness if sharpness is None else sharpness )","title":"adjust()"},{"location":"api/#jax_russell.ValuationModel","text":"Bases: ABC Abstract class for valuation methods. Source code in jax_russell/base.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 class ValuationModel ( abc . ABC ): \"\"\"Abstract class for valuation methods.\"\"\" argnums = list ( range ( 4 )) @abc . abstractmethod def value ( self , start_price : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" , ], volatility : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], time_to_expiration : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], risk_free_rate : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], cost_of_carry : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ]: \"\"\"Calculate the value of an option. This method is used internally by `__call__()`, and should return the value of options. By default, `__call__()` is a pass through to `value()`, but many available mixins overwrite this behavior to pass arguments to `value()`. In these cases, this allows the single, general method `value()` to implement valuations, while leveraging `__call__()` for security-specific argument logic and meaningful autodifferentiation. \"\"\" # noqa def __call__ ( self , * args : Any , ** kwargs : Any , ) -> jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ]: \"\"\"Value arrays of options. By default, `__call__` checks its arguments against `value()` and passes them through. Returns: jnp.array: option values \"\"\" inspect . signature ( self . value ) . bind ( * args , ** kwargs ) return self . value ( * jnp . broadcast_arrays ( * args ), ** kwargs ) @partial ( jax . jit , static_argnums = 0 ) def first_order ( self , * args , ** kwargs ): \"\"\"Automatically calculate first-order greeks. Returns: _type_: _description_ \"\"\" inspect . signature ( self ) . bind ( * args , ** kwargs ) return jnp . hstack ( jax . jacfwd ( self , self . argnums , )( * args , ** kwargs ) ) @partial ( jax . jit , static_argnums = 0 ) def second_order ( self , * args , ** kwargs ): \"\"\"Automatically calculate second-order greeks. Returns: _type_: _description_ \"\"\" inspect . signature ( self ) . bind ( * args , ** kwargs ) return jax . jacfwd ( self . first_order , self . argnums , )( * args , ** kwargs )","title":"ValuationModel"},{"location":"api/#jax_russell.ValuationModel.__call__","text":"Value arrays of options. By default, __call__ checks its arguments against value() and passes them through. Returns: Type Description Float [ Array , '#contracts'] jnp.array: option values Source code in jax_russell/base.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def __call__ ( self , * args : Any , ** kwargs : Any , ) -> jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ]: \"\"\"Value arrays of options. By default, `__call__` checks its arguments against `value()` and passes them through. Returns: jnp.array: option values \"\"\" inspect . signature ( self . value ) . bind ( * args , ** kwargs ) return self . value ( * jnp . broadcast_arrays ( * args ), ** kwargs )","title":"__call__()"},{"location":"api/#jax_russell.ValuationModel.first_order","text":"Automatically calculate first-order greeks. Returns: Name Type Description _type_ description Source code in jax_russell/base.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @partial ( jax . jit , static_argnums = 0 ) def first_order ( self , * args , ** kwargs ): \"\"\"Automatically calculate first-order greeks. Returns: _type_: _description_ \"\"\" inspect . signature ( self ) . bind ( * args , ** kwargs ) return jnp . hstack ( jax . jacfwd ( self , self . argnums , )( * args , ** kwargs ) )","title":"first_order()"},{"location":"api/#jax_russell.ValuationModel.second_order","text":"Automatically calculate second-order greeks. Returns: Name Type Description _type_ description Source code in jax_russell/base.py 93 94 95 96 97 98 99 100 101 102 103 104 @partial ( jax . jit , static_argnums = 0 ) def second_order ( self , * args , ** kwargs ): \"\"\"Automatically calculate second-order greeks. Returns: _type_: _description_ \"\"\" inspect . signature ( self ) . bind ( * args , ** kwargs ) return jax . jacfwd ( self . first_order , self . argnums , )( * args , ** kwargs )","title":"second_order()"},{"location":"api/#jax_russell.ValuationModel.value","text":"Calculate the value of an option. This method is used internally by __call__() , and should return the value of options. By default, __call__() is a pass through to value() , but many available mixins overwrite this behavior to pass arguments to value() . In these cases, this allows the single, general method value() to implement valuations, while leveraging __call__() for security-specific argument logic and meaningful autodifferentiation. Source code in jax_russell/base.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 @abc . abstractmethod def value ( self , start_price : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" , ], volatility : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], time_to_expiration : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], risk_free_rate : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], cost_of_carry : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], is_call : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], strike : jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ], ) -> jaxtyping . Float [ jaxtyping . Array , \"#contracts\" ]: \"\"\"Calculate the value of an option. This method is used internally by `__call__()`, and should return the value of options. By default, `__call__()` is a pass through to `value()`, but many available mixins overwrite this behavior to pass arguments to `value()`. In these cases, this allows the single, general method `value()` to implement valuations, while leveraging `__call__()` for security-specific argument logic and meaningful autodifferentiation. \"\"\" # noqa","title":"value()"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . [Unreleased] \u00b6 [0.1.1] - 2023-09-12 \u00b6 First release on PyPI. Added \u00b6 Cox-Ross-Rubinstein binomial trees (supports American and European) Rendleman Bartter trees (supports American and European) Mixin classes to support specific assets","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"[Unreleased]"},{"location":"changelog/#011---2023-09-12","text":"First release on PyPI.","title":"[0.1.1] - 2023-09-12"},{"location":"changelog/#added","text":"Cox-Ross-Rubinstein binomial trees (supports American and European) Rendleman Bartter trees (supports American and European) Mixin classes to support specific assets","title":"Added"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Share Test Cases \u00b6 If you're aware of a published source example option values or greeks, they could be very helpful in improving jax_russell testing. If sharing, please include: A link, if openly available; else, title and authors. A summary of the methods discussed in the source. Any details that might be helpful in leveraging the resource to improve tests. Share these resources at https://github.com/SeanEaster/jax_russell/issues. Report Bugs \u00b6 Report bugs at https://github.com/SeanEaster/jax_russell/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 jax_russell could always use more documentation, whether as part of the official jax_russell docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/SeanEaster/jax_russell/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up jax_russell for local development. Fork the jax_russell repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/jax_russell.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.11. Check https://github.com/SeanEaster/jax_russell/actions and make sure that the tests pass for all supported Python versions. Tips \u00b6 $ poetry run pytest tests/test_jax_russell.py To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: $ poetry run bump2version patch # possible: major / minor / patch $ git push $ git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#share-test-cases","text":"If you're aware of a published source example option values or greeks, they could be very helpful in improving jax_russell testing. If sharing, please include: A link, if openly available; else, title and authors. A summary of the methods discussed in the source. Any details that might be helpful in leveraging the resource to improve tests. Share these resources at https://github.com/SeanEaster/jax_russell/issues.","title":"Share Test Cases"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/SeanEaster/jax_russell/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"jax_russell could always use more documentation, whether as part of the official jax_russell docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/SeanEaster/jax_russell/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up jax_russell for local development. Fork the jax_russell repo on GitHub. Clone your fork locally $ git clone git@github.com:your_name_here/jax_russell.git Ensure poetry is installed. Install dependencies and start your virtualenv: $ poetry install -E test -E doc -E dev Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: $ poetry run tox Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.11. Check https://github.com/SeanEaster/jax_russell/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"$ poetry run pytest tests/test_jax_russell.py To run a subset of tests.","title":"Tips"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run: $ poetry run bump2version patch # possible: major / minor / patch $ git push $ git push --tags GitHub Actions will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install jax_russell, run this command in your terminal: $ pip install jax_russell This is the preferred method to install jax_russell, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for jax_russell can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/SeanEaster/jax_russell Or download the tarball : $ curl -OJL https://github.com/SeanEaster/jax_russell/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install jax_russell, run this command in your terminal: $ pip install jax_russell This is the preferred method to install jax_russell, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for jax_russell can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/SeanEaster/jax_russell Or download the tarball : $ curl -OJL https://github.com/SeanEaster/jax_russell/tarball/master Once you have a copy of the source, you can install it with: $ pip install .","title":"From source"},{"location":"usage/","text":"Usage \u00b6 To use jax_russell in a project import jax_russell","title":"Usage"},{"location":"usage/#usage","text":"To use jax_russell in a project import jax_russell","title":"Usage"}]}